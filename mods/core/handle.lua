--- Lua-side storage for safe references to C++ objects.
--
-- Whenever a new object is initialized, a corresponding handle will
-- be created here to track the object's lifetime in an isolated Lua
-- environment managed by a C++ handle manager. If the object is no
-- longer valid for use (a character died, or an item was destroyed),
-- the C++ side will set the Lua side's handle to be invalid. An
-- error will be thrown on trying to access or write to anything on
-- an invalid handle. Since objects are identified by simple integer
-- ids, this also allows for relatively simple serialization of such
-- references to C++ objects from Lua, allowing us to save the state
-- of any mods that are in use along with the base save data.
--
-- This mechanism is a solution for the problem of what happens when a
-- user assigns a C++ object reference to a deeply nested Lua table,
-- then that reference goes invalid on the C++ side. Originally an
-- approach was attempted where the C++ storage mechanism bound to Lua
-- attempted to detect invalid references when they were accessed.
-- This didn't work, because it didn't solve the problem of what
-- happens when the reference is assigned to a nested Lua table which
-- is referenced in the C++ storage. The C++ code would have to
-- iterate every possible nested table value to check for any invalid
-- references. This solution is more lightweight and robust since a
-- simple flag can be set on a handle and all references to it will be
-- updated automatically.
--
-- Borrowed from https://eliasdaler.github.io/game-object-references/

local Handle = {}
local inspect = require "mods/core/inspect"

Handle.CharaHandles = {}
Handle.ItemHandles = {}

local function print_handle_error(key)
   if _IS_TEST then return end

   if Elona.GUI then
      Elona.GUI.txt_color(3)
      Elona.GUI.txt("Error: handle is not valid! ")
      if key ~= nil then
         Elona.GUI.txt("Indexing: " .. tostring(key) .. " ")
      end
      Elona.GUI.txt("This means the character/item got removed. ")
      Elona.GUI.txt_color(0)
   end
   print("Error: handle is not valid!")
   print(debug.traceback())
end

-- Cache for function closures resolved when indexing a handle.
-- Creating a new closure for every method lookup is expensive.
-- Indexed by [class_name][method_name].
local memoizedFuncs = {}

local function generate_metatable(core_table, prefix)
   local mt = {}
   memoizedFuncs[prefix] = {}
   mt.__index = function(handle, key)
      if not handle.is_valid then
         print_handle_error(key)
         error("Error: handle is not valid!", 2)
      end

      -- Try to get a property out of the C++ reference.
      local v = handle.cpp_ref[key]
      if v ~= nil then
         if type(v) ~= "function" then
            return v
         end
      end

      -- If that fails, try calling a function by the name given.
      local f = memoizedFuncs[prefix][key]
      if not f then
         -- Look up the function on the usertype table generated by
         -- sol2.
         f = function(handle, ...) return core_table[key](handle.cpp_ref, ...) end

         -- Cache it so we don't incur the overhead of creating a
         -- closure on every lookup.
         memoizedFuncs[prefix][key] = f
      end
      return f
   end
   mt.__newindex = function(handle, key, value)
      if not handle.is_valid then
         print_handle_error(key)
         error("Error: handle is not valid!", 2)
      end

      handle.cpp_ref[key] = value
   end
   return mt
end

local chara_mt = generate_metatable(LuaCharacter, "LuaCharacter")
local item_mt = generate_metatable(LuaItem, "LuaItem")


function Handle.create_chara_handle(cpp_ref)
    local handle = {
        cpp_ref = cpp_ref,
        is_valid = true
    }

    setmetatable(handle, chara_mt)
    Handle.CharaHandles[cpp_ref.index] = handle
    return handle
end

function Handle.create_item_handle(cpp_ref)
    local handle = {
        cpp_ref = cpp_ref,
        is_valid = true
    }

    setmetatable(handle, item_mt)
    Handle.ItemHandles[cpp_ref.index] = handle
    return handle
end


function Handle.remove_chara_handle(cpp_ref)
    local handle = Handle.CharaHandles[cpp_ref.index];
    handle.cpp_ref = nil
    handle.is_valid = false
    Handle.CharaHandles[cpp_ref.index] = nil
end

function Handle.remove_item_handle(cpp_ref)
    local handle = Handle.ItemHandles[cpp_ref.index];

    handle.cpp_ref = nil
    handle.is_valid = false
    Handle.ItemHandles[cpp_ref.index] = nil
end


function Handle.assert_chara_valid(cpp_ref)
   local handle = Handle.CharaHandles[cpp_ref.index];
   assert(handle.is_valid)
end

function Handle.assert_item_valid(cpp_ref)
   local handle = Handle.ItemHandles[cpp_ref.index];
   assert(handle.is_valid)
end


function Handle.assert_chara_invalid(cpp_ref)
   local handle = Handle.CharaHandles[cpp_ref.index];
   assert(handle == nil or not handle.is_valid)
end

function Handle.assert_item_invalid(cpp_ref)
   local handle = Handle.ItemHandles[cpp_ref.index];
   assert(handle == nil or not handle.is_valid)
end


local function iter (a, i)
   local v = a.handles[i]
   while not (v and rawget(a.handles[i], "is_valid")) do
      if i >= a.to then
         return nil
      end
      i = i + 1
      v = a.handles[i]
   end
   i = i + 1
   return i, v
end


-- These functions exist in the separate handle environment because I
-- couldn't quite figure out how to make a valid custom C++/Lua
-- iterator with Sol that returns Lua table references as values.

-- Chara.iter(from, to)
function Handle.iter_charas(from, to)
   if from > to then
      return nil
   end
   return iter, {handles=Handle.CharaHandles, to=to}, from
end

-- Item.iter(from, to)
function Handle.iter_items(from, to)
   if from > to then
      return nil
   end
   return iter, {handles=Handle.ItemHandles, to=to}, from
end


return Handle
