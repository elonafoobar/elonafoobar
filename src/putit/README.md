# Putit

Serialization library for Elona foobar

All serialize() functions Elona foobar use for marshalling are automatically generated by this tool, `putit.py`.


# Usage

## Define struct or class

```cpp
/// @putit
struct S
{
    /// @putit
    int x;

    /// @putit
    int y;

    int it_is_not_serialized;

#include "_putit/s.cpp"
};
```

First, add `/// @putit` magic comment above `struct Position`.

> Note: this keyword is case-sensitive and extra characters including spaces are not allowd. In addition, it must appear exactly above `struct` or `class` keyword.

Second, add the same magic comments to serialized fields. Non-annotated fields are not serialized.

> Note: these comments are case-sensitive and extra characters are not allowed, too. Also, they must appear exactly above variable declarations, too.

Third, add `#include` directive. The name has no limitation, but should be `_putit/{struct or class name in snake case}.cpp`. Please look at `src/elona/_putit` folder.

Finally, when you newly add fields to any existing structures, do not remember add migration code to `src/elona/save_update.cpp`. Any changes to data structures must not break player's save.


## Run putit.py script

Then, execute `putit.py`.

```sh
$ src/putit/bin/putit.py
Processing /Users/keik/src/ki-elonafoobar/src/elona/keybind/input_context.hpp...Done
Processing /Users/keik/src/ki-elonafoobar/src/elona/keybind/keybind.hpp...Done
Processing /Users/keik/src/ki-elonafoobar/src/elona/keybind/keybind_deserializer.hpp...Done
...
Processing /Users/keik/src/ki-elonafoobar/src/elona/data/types/type_portrait.hpp...Done
Position's serializer has successfully been generated.
Buff's serializer has successfully been generated.
ContinuousAction's serializer has successfully been generated.
Character's serializer has successfully been generated.
...
Ability's serializer has successfully been generated.
```

The results need managing in `git`. Do `git add` and commit.


## Continuous Integration

CI checks all auto-generate code are the latest and there is no change. In other words, CI run `putit.py` once, and check the result of `git diff`. If some difference is detected, CI reports error and aborts.


# Why "putit"?

Because blobs the library generates are small.
